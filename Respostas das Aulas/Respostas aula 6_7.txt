Data: 31/03/2017

Para cada questão, escreva funções em C e/ou sub-rotinas na linguagem Assembly do MSP430. Reaproveite funções e sub-rotinas de uma questão em outra, se assim desejar. Leve em consideração que as sub-rotinas são utilizadas em um código maior, portanto utilize adequadamente os registradores R4 a R11. As instruções da linguagem Assembly do MSP430 se encontram ao final deste texto.

1. (a) Escreva uma função em C que calcule a raiz quadrada 'x' de uma variável 'S' do tipo float, utilizando o seguinte algoritmo: após 'n+1' iterações, a raiz quadrada de 'S' é dada por

	x(n+1) = (x(n) + S/x(n))/2
 R:
unsigned int Raiz_Quadrada(unsigned int S)
{
        unsigned int interacoes = 15;
        float x0 = S;
        float x;
        int n;
        for(n = 0; n <= interacoes; n++){
            x = (x0 + (S/x0))/2;
            x0 = x;
        }
	return (unsiged int)x;
}

O protótipo da função é:

	unsigned int Raiz_Quadrada(unsigned int S);

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável 'S' é fornecida pelo registrador R15, e a raiz quadrada de 'S' (ou seja, a variável 'x') é fornecida pelo registrador R15 também.

CalculaRaiz: add.w #1,R11    ; calcula div R15/R13 e guarda em R15 --> (R15 = R15/R13)
	     mov.w #0,R12    ; registrador que guarda o "resultado" primário para divisao  		
             mov.w R15,R14   ; copia R15(numerador) para R14(registrador temporario). 
	     jz fimMult	     ; se o numerador for Zero, a divisão termina
looping:     sub.w R13,R14;  ; 
             jn fimDiv	     ; se o valor de SUB R13,R14 for negativo então a divisão termina.
	     cmp.w R14,R15   ; se a divisão for por zero, essa comparação permite terminar a div.
	     jz fimDiv       ; should never happen.
	     add.w #1,R12    ; vai adicionando um valor ao resultado até o resultado final.
	     jmp looping     ; looping para somar repetidas vezes até R12 ser Zero.
fimDiv: 		   
			     ; ------------------------------------------------------- 
	     add.w R13,R12   ; R15 = Xo + (S/Xo)
	     rra.w R12	     ;       -----------
	     mov.w R12,R15   ;            2
	     sub.w #15,R11   ; analisa as 15 interações
	     jn Fim          ; FIM
	     jmp CalculaRaiz ; looping de interações	
Fim	                     ;

2. (a) Escreva uma função em C que calcule 'x' elevado à 'N'-ésima potência, seguindo o seguinte protótipo: 

	int_potencia(int x, int N){
	int sign = 0, p =1;
	if(N < 0){
		N =-N;
		sign = 1;
	}
	while(N > 0){
		P = Mult_Signed(x,p);
		N--;
	}
	if(sign == 1)
		return Div_signed(1,p);
	else
		return p;

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. 'x' e 'n' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida no registrador R15.

		push R4
		push R5
Potencia:	clr R4;		; sign = 0
		mov #1, R15	; p = 1
		cmp #1,R14
		jl While_pot
		inv R14
		inc R14
		mov #1,R4
While_pot: 	tst R14
		jz While_pot_end
		push R15
		push R14
		mov R5,R14
		call Mult_signed
		mov R15,R5
		pop R14
		pop R15
		dec R14
		jmp While_pot
		jl While_pot_end
		push R15
		push R14
While_pot_end:	cmp #1,R4
		jne Pot_end
		mov #1,R15
		mov R5,R14
		call Div_Signed
		pop R5
		pop R4
		ret
Pot_end:	mov R5,R15
		pop R5
		pop R4
		ret


3. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula a divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.

Div_unsigned:
		clr R13		;  R13 = 0
for_div		cmp R14,R15 	; compara R14 e R15
		jl End_for_div	; se a for menor que b pule para o fim	
		sub R14,R15	; a = a - b
		inc R13		;  i++
		jmp for_div	; volte ao looping
End_for_div: 	mov R13,R15	; 
		ret


4. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o resto da divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.

Div_rest:
		clr R13		;  R13 = 0
for_div		cmp R14,R15 	; compara R14 e R15
		jl End_for_div	; se a for menor que b pule para o fim	
		sub R14,R15	; a = a - b
		inc R13		;  i++
		jmp for_div	; volte ao looping
End_for_div: 	
		ret

5. (a) Escreva uma função em C que indica a primalidade de uma variável inteira sem sinal, retornando o valor 1 se o número for primo, e 0, caso contrário. Siga o seguinte protótipo:

	int Primalidade(unsigned int x)
	{
		if(x<2) return 0;
		for(int i = 2;; i++)
		{
			if(x % i == 0 && x != i)
				return 1;
		}
		return 0;
	}

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

		push R5		; guarde na pilha
		push R4		; guarde na pilha
Primo:		cmp #2,R15	;testar se x < 2
		jge for		; se x>= 2, pule para for
		mov.w #0,R15	; return 0
		ret		; retorne para onde a função foi chamada
for:		push R14	; guarde R14 na pilha
		push R15	; guarde na pilha
		mov #2,R14       ; i = 2
		call Div_rest	; chamar a função que calcula o resto da divisão


6. Escreva uma função em C que calcula o duplo fatorial de n, representado por n!!. Se n for ímpar, n!! = 1*3*5*...*n, e se n for par, n!! = 2*4*6*...*n. Por exemplo, 9!! = 1*3*5*7*9 = 945 e 10!! = 2*4*6*8*10 = 3840. Além disso, 0!! = 1!! = 1.
O protótipo da função é:

	unsigned long long DuploFatorial(unsigned long long n)
	{
		if(n < 2) return 1;
		unsigned long long retn = 1;
		for(unsigned long long i = n; i >= 2; i=i-2)
			retn *= i;
		
	}

7. (a) Escreva uma função em C que calcula a função exponencial da seguinte forma:
	
Considere o cálculo até o termo n = 20. O protótipo da função é double ExpTaylor(double x);


(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430, mas considere que os valores de entrada e de saída são inteiros de 16 bits. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

8. Escreva uma sub-rotina na linguagem Assembly do MSP430 que indica se um vetor esta ordenado de forma decrescente. Por exemplo:
[5 4 3 2 1] e [90 23 20 10] estão ordenados de forma decrescente.
[1 2 3 4 5] e [1 2 3 2] não estão.
O primeiro endereço do vetor é fornecido pelo registrador R15, e o tamanho do vetor é fornecido pelo registrador R14. A saída deverá ser fornecida no registrador R15, valendo 1 quando o vetor estiver ordenado de forma decrescente, e valendo 0 em caso contrário.

9. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o produto escalar de dois vetores, 'a' e 'b':
	
O primeiro endereço do vetor 'a' deverá ser passado através do registrador R15, o primeiro endereço do vetor 'b' deverá ser passado através do registrador R14, e o tamanho do vetor deverá ser passado pelo registrador R13. A saída deverá ser fornecida no registrador R15.

10. (a) Escreva uma função em C que indica se um vetor é palíndromo. Por exemplo:
	[1 2 3 2 1] e [0 10 20 20 10 0] são palíndromos.
	[5 4 3 2 1] e [1 2 3 2] não são.
Se o vetor for palíndromo, retorne o valor 1. Caso contrário, retorne o valor 0. O protótipo da função é:

	int Palindromo(int vetor[ ], int tamanho);

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. O endereço do vetor de entrada é dado pelo registrador R15, o tamanho do vetor é dado pelo registrador R14, e o resultado é dado pelo registrador R15.
